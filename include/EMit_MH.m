function [theta, x, lnw, lnk, lng_y, lnw_x, x_smooth, accept] = EMit_MH(y, N, kernel_prior, kernel, mit, GamMat, MH)
% sample N draws from mixture of t's mit and evaluate them on the kernel
% if MH = true then also perform independence MH on the drawn sample
% with using mit as the candidate density
% input:
% N - lenght of the generated chain
% kernel - function which computes the kernel
% mit - mixture of t's
% output:
% theta - [Nxk] matrix of samples generated by the independence MH (or just drawm from mit)
% accept - acceptance rate in the independence MH
    resampl_on = false;
    T = size(y,1);
    x_smooth = [];

    [theta, ~] = fn_rmvgt_robust(N, mit, kernel_prior, resampl_on);
    
    if (N <= 2000)
%         [theta, lnk, ~, x, lng_y, lnw_x, x_smooth] = fn_rmvgt_robust(N, mit, kernel, theta);
        [theta, lnk, ~, x, lng_y, lnw_x] = fn_rmvgt_robust(N, mit, kernel, resampl_on, theta);
    else
        lnk = zeros(N,1);
        x = zeros(N,T); 
        lng_y = zeros(N,1);
        lnw_x = zeros(N,1);
%         x_smooth = zeros(T,N);
        for ii = 1:(N/1000)
            ind = (1:1000) + (ii-1)*1000; 
%             [theta(ind,:), lnk(ind,:), ~, x(ind,:), lng_y(ind,:), lnw_x(ind,:), x_smooth(:,ind)] = fn_rmvgt_robust(1000, mit, kernel, theta(ind,:));      
            [theta(ind,:), lnk(ind,:), ~, x(ind,:), lng_y(ind,:), lnw_x(ind,:)] = fn_rmvgt_robust(1000, mit, kernel, resampl_on, theta(ind,:));      
        end
    end
    lnd = dmvgt(theta, mit, true, GamMat);
    lnw = lnk - lnd;
    lnw = lnw - max(lnw);
    
    if MH
        fprintf('MH running...\n')
        [theta, x, lnw, lnk,  lng_y, lnw_x, a] = fn_MH(theta, x, lnw, lnk, lng_y, lnw_x);
        accept = a/N;   
        x_smooth = [];
    else 
        accept = 100;
    end
        
end


function [draws, draws_x, draws_lnw, draws_lnk, draws_lng_y, draws_lnw_x, a] = fn_MH(theta, x, lnw, lnk,  lng_y, lnw_x)
% a - counter for accepted draws
    [N,d] = size(theta);
    T = size(x,2);
    a = 0;
    % initialize the chain
    draws = zeros(N,d);
    draws(1,:) = theta(1,:);
    
    draws_x = zeros(N,T);
    draws_x(1,:) = x(1,:);
     
    draws_lnw = zeros(N,1);
    draws_lnw(1,1) = lnw(1,1);

    draws_lnk = zeros(N,1);
    draws_lnk(1,1) = lnk(1,1);    

    draws_lng_y = zeros(N,1);
    draws_lng_y(1,1) = lng_y(1,1);    

    draws_lnw_x = zeros(N,1);
    draws_lnw_x(1,1) = lnw_x(1,1);   
    
    ind_old = 1;
    
%     h = waitbar(0,'MH in progress...');
    % iterate over the chain
    for ii = 2:N
        u = rand; % draw from uniform
%         e = min(1,w(ii)/w(ind_old)); % min between the ratio and 1
        e = min(1, exp(lnw(ii)-lnw(ind_old))); % min between the ratio and 1
        if (u <= e)
            draws(ii,:) = theta(ii,:);
            draws_x(ii,:) = x(ii,:);
            draws_lnw(ii,1) = lnw(ii,1);
            draws_lnk(ii,1) = lnk(ii,1);
            draws_lng_y(ii,1) = lng_y(ii,1);
            draws_lnw_x(ii,1) = lnw_x(ii,1);

            a = a + 1;  % increase the counter for acceptance rate
            ind_old = ii; % move the old position
        else 
            draws(ii,:) = theta(ind_old,:);
            draws_x(ii,:) = x(ind_old,:);
            draws_lnw(ii,1) = lnw(ind_old,1);
            draws_lnk(ii,1) = lnk(ind_old,1);
            draws_lng_y(ii,1) = lng_y(ind_old,1);
            draws_lnw_x(ii,1) = lnw_x(ind_old,1);
        end 
%          waitbar(ii/N)
    end
%     close(h) 
end