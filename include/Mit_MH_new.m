function [theta, accept, lnw, lnk, lnd] = Mit_MH_new(N, kernel, mit, GamMat)
% perform independence MH sampling using mixture of t densities as the
% candidate density
% input:
% N - lenght of the generated chain
% kernel - function which computes the kernel
% mit - mixture details
% output:
% theta - [Nxk] matrix of samples generated by the independence MH
% accept - acceptance rate in the independence MH
   % N = 1e5; 
    resampl_on = false;
    
    [theta, lnk, ~] = fn_rmvgt_robust(N, mit, kernel, resampl_on);
    ind_real = ((imag(lnk)==0) & ~isnan(lnk));
    lnk(~ind_real) = -Inf;
  
    lnd = dmvgt(theta, mit, true, GamMat);
    norm = false;
    lnw = fn_ISwgts(lnk, lnd, norm);
    lnw = log(lnw); %log weights 

    [ind, a] = fn_MH(lnw);
    theta = theta(ind,:);
    lnw = lnw(ind,:);
    lnk = lnk(ind,:);
    lnd = lnd(ind,:);
        
    accept = a/N;
end


function [ind, a] = fn_MH(lnw)
% a - counter for accepted draws
    [N,~] = size(lnw);
    a = 0;
    % initialize the chain
    ind = zeros(N,1);
    ind(1,:) = 1;

    ind_old = 1;
    
%     h = waitbar(0,'MH in progress...');
    % iterate over the chain
    for ii = 2:N
        u = rand; % draw from uniform
%         e = min(1,w(ii)/w(ind_old)); % min between the ratio and 1
        e = min(1, exp(lnw(ii)-lnw(ind_old))); % min between the ratio and 1
        if (u <= e)
            ind(ii,:) = ii;
            a = a + 1;  % increase the counter for acceptance rate
            ind_old = ii; % move the old position
        else 
            ind(ii,:) = ind_old;
        end 
%          waitbar(ii/N)
    end
%     close(h) 
end